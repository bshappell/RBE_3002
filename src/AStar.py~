#!/usr/bin/env python

import math 
import numpy
class GridSquare:
    def __init__(self, checked, h, g, cameFrom):
        self.checked = checked # 0 = unchecked, 1 = checked, 2 = wall,  3 = frontier
        self.h = h
        self.g = g
        self.cameFrom = cameFrom 

class FrontierSquare:
    def __init__(self, x, y, f):
        self.x = x
        self.y = y
        self.f = f

#it's recommended that start is a poseStamped msg and goal is a pose msg, RViz likes using that for visualization.
def AStar(ixInit, iyInit, ixEnd, iyEnd, iwidth, iheight):

    global width
    global height
    global xEnd
    global yEnd
    global xInit
    global yInit

    xInit = ixInit
    yInit = iyInit
    xEnd = ixEnd
    yEnd = iyEnd
    width = iwidth
    height = iheight

    print xInit
    print yInit

    frontier = [] # list of frontier squares 

    mapInfo = [] # 2d array of grid square info
    row = []
    for i in range(height):
        row.append(GridSquare(0, 0, 0, (0,0))) # append empty grid cell
    for i in range(width):
        mapInfo.append(row)

    print mapInfo[0]


    # calculate out heursitics at each coordinate
    getHeuristic(mapInfo)

	# starting x and y are the current coordinates
    curr_x = xInit
    curr_y = yInit

    # Determine current f value
    curr_f = mapInfo[curr_x][curr_y].h + mapInfo[curr_x][curr_y].g

    # add starting square to frontier
    frontier.append(FrontierSquare(curr_x, curr_y, curr_f))

    while(len(frontier)): # while there are still nodes that have not been checked, continually run the algorithm
	
        currentSquare = frontier[0] # this is the most promising node of all nodes in the open set
        frontier = frontier[1:len(frontier)] # remove currentSquare from the frontier
        
        curr_x = currentSquare.x
        curr_y = currentSquare.y

        if (curr_x == xEnd) and (curr_y == yEnd): # if the best possible path found leads to the goal, it is the best possible path that the robot could discover
            print("goal reached")            
            return reconstruct_path(came_from, goal)
         
        neighbors = getNeighbors(currentSquare, mapInfo) # re-evaluate each neighboring node

        # add from frontier
        frontier.append(neighbor)

        # sort frontierList by f (g(s) + h(s))
        frontier.sort(key=lambda state: state.f)
 
    return failure #if the program runs out of nodes to check before it finds the goal, then a solution does not exist


#mapInfo, is list of list of GridSquares
def getHeuristic(mapInfo):
    global xEnd
    global yEnd
    global width
    global height

    for x in range(width):
		for y in range(height):
			xDist = xEnd - x
			yDist = yEnd - y
            dist = xDist** 2 - yDist**2
            print dist
			mapInfo[x][y].h = math.sqrt(dist)

#Sets x,y to checked
#Sets came from in checked neighbors
#Checks if wall and sets checked status true on walls
#Returns list of cardinal neighbors tuple
def getNeighbors(currentCell, mapInfo):
	global width
	global height
	
	#set current cell to checked
	mapInfo[currentCell.x][currentCell.y].checked = 1
    #check neighbor to north
	delta_x = [0,1,0,-1]
	delta_y = [1,0,-1,0]
	frontierList = []

	for i in range(len(delta_x)):
		new_x = cuurentCell.x + delta_x[i]
		new_y = currentCell.y + delta_y[i]

		#if in bounds (equal to zero less than width)
		if 0 <= new_x < width and 0 <= new_y < height:
			#if the neighbor cell has not been checked
			if mapInfo[new_x][new_y].checked == 0:
				#set the came from value for the new cell
				'''mapInfo[new_x][new_y].cameFrom = (currentCell.x, currentCell.y)
				#set the cell checked value as frontier
				mapInfo[new_x][new_y].checked = 3
				# set the g value to the g value of the parent node plus one
				mapInfo[new_x][new_y].g =mapInfo[currentCell.x][currentCell.y].g + 1 
				#append the new cell to the frontierList
				frontierList.append(FrontierSquare(new_x, new_y, 0))
	            #((mapInfo[new_x][new_y].checked == 1) or (mapInfo[new_x][new_y].checked == 3)):
	                tentative_g = manInfo[currentCell.x][currentCell.y].g + 1
	                if tentative_g < mapInfo[new_x][new_y].g:
	                    mapInfo[new_x][new_y].g = tentative_g
	                    mapInfo[new_x][new_y].cameFrom = (currentCell.x, currentCell.y)'''

	#return a list FrontierSquares
	return frontierList

#returns the distance from the initial pose to the current position
#looks at where the neighbor came from and then adds one to that g value
def getDistance(currentCell, mapInfo):

	return 1

#returns array of PoseStamps
def reconstructPath(goalCell, mapInfo):
	global xInit
	global yInit

	Path = []
	currentCell = goalCell

	while currentCell.x != xInit or currentCel.y != yInit:
		nextCell = mapInfo[currentCell.x][currentCell.y].cameFrom
		Path.append(currentCell)
		currentCell = nextCell

    #if we have reached the end
	return Path


	



